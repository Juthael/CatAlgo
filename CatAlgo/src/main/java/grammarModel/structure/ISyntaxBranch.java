package grammarModel.structure;

import java.util.List;
import java.util.Map;

import grammarModel.exceptions.GrammarModelException;
import grammarModel.utils.ITreePaths;

/**
 * <p>
 * Any <i> class </i> implementing the syntax branch interface defines derivation rule of a context-free 
 * grammar. As any syntactic structure does, it uses the composition relationship between classes ("any instance 
 * of class <i> A </i> is composed of an instance of class <i> B </i> and an instance of class <i> C </i>") 
 * as an equivalent of the derivation relationship between symbols ("the symbol <i> A </i> can be substituted 
 * by the string of symbols <i> BC </i> "). <br>
 * </p>
 * 
 * <p>
 * Thus, any <i> instance </i> of a class implementing the syntax branch interface represents a derivation of a 
 * nonterminal symbol (the one that gives the structure its name) in the form of a syntax tree. As a result of this 
 * derivation, any syntax branch instance yields a string of terminals that forms a <i> functional expression </i>, 
 * which is a descriptive statement about the object to which this structure applies. 
 * The functional expression of a syntax branch consists in the application of arguments to a function. This function 
 * is given by the "function leaf" component that characterizes every syntax branch instance ; the function's 
 * arguments are the strings of terminals generated by the other components.   
 * </p> 
 * 
 * @see grammarModel.structure.ISyntacticStructure
 * @see grammarModel.structure.ISyntaxLeaf
 * @see representation.IFunctionalExpression
 * @author Gael Tregouet
 *
 */
public interface ISyntaxBranch extends ISyntacticStructure {
	
	//getters
	
	/**
	 * Returns the components whose generated functional expressions are the arguments of this syntax branch's function. 
	 * 
	 * @see representation.IFunctionalExpression
	 * @return the components that generate the arguments of this branch's function
	 */
	List<ISyntacticStructure> getArguments();
	
	/**
	 * Returns this branch's function, in the form of a syntax leaf. 
	 * 
	 * @return the branch's function
	 */
	ISyntaxLeaf getFunction();	
	
	/**
	 * Returns the list of IDs associated with any terminal ({@link ISyntaxLeaf}) derived from this structure's root. <br>
	 * 
	 * The returned list is a concatenation of the lists returned by this branch components. <br>
	 * 
	 * @see grammarModel.structure.ISyntaxLeaf
	 * @return the list of IDs associated with any terminal ({@link ISyntaxLeaf}) derived from this structure's root. 
	 */
	@Override
	List<Long> getListOfLeafIDs();
	
	/**
	 * Returns the list of paths (as a list of lists of strings) in this structure's tree, from the symbol that gives 
	 * the syntactic structure its name to any reachable terminal. <br>
	 * 
	 * The {@link ITreePaths} is constructed out of every component's tree paths. They are all included in a single set 
	 * of paths and the structure's name is inserted at the beginning of every path. 
	 * 
	 * @return the list of paths from the symbol that gives the syntactic structure its name to any reachable terminal.
	 */
	@Override
	List<List<String>> getPathsAsListsOfStrings();
	
	/**
	 * Returns the list of paths (with navigating functionalities) in this structure's tree, from the symbol that gives 
	 * the syntactic structure its name to any reachable terminal. <br>
	 * 
	 * The {@link ITreePaths} is constructed out of every component's tree paths. 
	 * 
	 * @return the list of paths from the symbol that gives the syntactic structure its name to any reachable terminal.
	 * @throws GrammarModelException
	 */
	@Override
	ITreePaths getTreePaths() throws GrammarModelException;		
	
	/**
	 * Returns true if this syntax branch is a tree, i.e. if its name is the start element of the context-free
	 * grammar at use.
	 * 
	 * @return true if this syntax branch is a tree
	 */
	boolean isATree();	
	
	//setters
	
	/**
	 * Adds a distinctive mark to the function leaves derived from recursive symbols. <br> 
	 * 
	 * The branch's recursion index must have been set previously. If this index equals <i> n </i>, then the 
	 * function leaf of this branch has <i> n </i> recursion marks added at the end of its name. 
	 * 
	 * This method is recursively called in every component of the branch.   
	 */
	@Override
	void markRecursion();
	
	/**
	 * 
	 */
	@Override
	boolean replaceComponents(ISyntacticStructure newComp, List<Long> compIDs);
	
	/**
	 * <p>
	 * The recursion index equals the maximum number of occurrences of the structure's name that can be found in 
	 * a single <i> argument </i> path of its syntax tree, minus one. <br>
	 * 
	 * An argument path is a path does not lead to the structure's <i> function </i>. <br>
	 * </p>
	 * 
	 * <p>
	 * How it works (<i> X </i> and <i> Y </i> are any substring) : <br>
	 * <i> a -> X -> a -> Y -> a </i> : first <i> A </i>'s recursion index is 2 <br>
	 * </p>.
	 * 
	 * <p>
	 * This method must be called first on every argument component of the branch. The returned maps are merged in 
	 * such a way that, if a symbol is mapped to different values, only the biggest one is kept. <br>
	 * If this branch's name is already mapped to a value, this value is incremented by one in the map and retained
	 * REVOIR ICI 
	 * 
	 * </p>
	 * 
	 * @return
	 * @throws GrammarModelException 
	 */
	@Override
	Map<String, Integer> setRecursionIndex() throws GrammarModelException;

}
