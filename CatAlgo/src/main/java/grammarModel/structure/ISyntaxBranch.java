package grammarModel.structure;

import java.util.List;
import java.util.Map;

import grammarModel.exceptions.GrammarModelException;
import grammarModel.utils.ITreePaths;

/**
 * <p>
 * Any <i> class </i> implementing the syntax branch interface defines derivation rule of a context-free 
 * grammar. As any syntactic structure does, it uses the composition relationship between classes ("any instance 
 * of class <i> A </i> is composed of an instance of class <i> B </i> and an instance of class <i> C </i>") 
 * as an equivalent of the derivation relationship between symbols ("the symbol <i> A </i> can be substituted 
 * by the string of symbols <i> BC </i> "). <br>
 * </p>
 * 
 * <p>
 * Thus, any <i> instance </i> of a class implementing the syntax branch interface represents a derivation of a 
 * nonterminal symbol (the one that gives the structure its name) in the form of a syntax tree. As a result of this 
 * derivation, any syntax branch instance yields a string of terminals that forms a <i> functional expression </i>, 
 * which is a descriptive statement about the object to which this structure applies. 
 * The functional expression of a syntax branch consists in the application of a function to a list of arguments. 
 * This function is given by the "function leaf" component that characterizes every syntax branch instance ; the 
 * function's arguments are the strings of terminals generated by the other components.   
 * </p> 
 * 
 * @see grammarModel.structure.ISyntacticStructure
 * @see grammarModel.structure.ISyntaxLeaf
 * @see representation.IFunctionalExpression
 * @author Gael Tregouet
 *
 */
public interface ISyntaxBranch extends ISyntacticStructure {
	
	//getters
	
	/**
	 * Returns the components whose generated functional expressions are the arguments of this syntax branch's function. 
	 * 
	 * @see representation.IFunctionalExpression
	 * @return the components that generate the arguments of this branch's function
	 */
	List<ISyntacticStructure> getArguments();
	
	/**
	 * Returns this branch's function, in the form of a syntax leaf. 
	 * 
	 * @return the branch's function
	 */
	ISyntaxLeaf getFunction();	
	
	/**
	 * Returns the list of IDs associated with any terminal ({@link ISyntaxLeaf}) derived from this structure's root. <br>
	 * 
	 * The returned list is a concatenation of the lists returned by this branch components. <br>
	 * 
	 * @see grammarModel.structure.ISyntaxLeaf
	 * @return the list of IDs associated with any terminal ({@link ISyntaxLeaf}) derived from this structure's root. 
	 */
	@Override
	List<Long> getListOfLeafIDs();
	
	/**
	 * Returns the list of paths (as a list of lists of strings) in this structure's tree, from the symbol that gives 
	 * the syntactic structure its name to any reachable terminal. <br>
	 * 
	 * The list is constructed out of every component's paths lists. They are all included in a single list 
	 * of paths and the structure's name is inserted at the beginning of every path. 
	 * 
	 * @return the list of paths from the symbol that gives the syntactic structure its name to any reachable terminal.
	 */
	@Override
	List<List<String>> getPathsAsListsOfStrings();
	
	/**
	 * Returns the list of paths (with navigating functionalities) in this structure's tree, from the symbol that gives 
	 * the syntactic structure its name to any reachable terminal. <br>
	 * 
	 * The {@link ITreePaths} is constructed out of every component's tree paths. 
	 * 
	 * @return the list of paths from the symbol that gives the syntactic structure its name to any reachable terminal.
	 * @throws GrammarModelException
	 */
	@Override
	ITreePaths getTreePaths() throws GrammarModelException;		
	
	/**
	 * Returns true if this syntax branch is a tree, i.e. if its name is the start element of the context-free
	 * grammar at use.
	 * 
	 * @return true if this syntax branch is a tree
	 */
	boolean isATree();	
	
	//setters
	
	/**
	 * Adds a distinctive mark to the function leaves derived from recursive symbols. <br> 
	 * 
	 * The branch's recursion index must have been set previously. If this index equals <i> n </i>, then the 
	 * function leaf of this branch has <i> n </i> recursion marks added at the end of its name. 
	 * 
	 * This method is recursively called in every component of the branch. 
	 * 
	 * @see grammarModel.structure.ISyntaxLeaf
	 */
	@Override
	void markRecursion();
	
	/**
	 * <p>
	 * Replaces a terminal ({@link ISyntaxLeaf}) component by a new component, provided that the terminal is 
	 * declared as implementing an interface whose the new component is also an implementation of. <br>
	 * </p>
	 * 
	 * <p>
	 * Syntax tree 'growth' involves the replacement of leaves by new branches ; or, rarely, by new leaves. <br> 
	 * These new components are injected in the structure with the IDs of the leaf they are meant to replace. If one 
	 * of the structure component is a target leaf, then it is replaced ; otherwise, the same method is recursively 
	 * called on every non-terminal component, with the same parameters. <br>
	 * </p>
	 * 
	 * @see grammarModel.structure.ISyntaxLeaf
	 * @param newComp new syntactic component
	 * @param compIDs IDs of the leaves to be replaced
	 * @return true if a replacement has occurred. 
	 */
	@Override
	boolean replaceComponents(ISyntacticStructure newComp, List<Long> compIDs);
	
	/**
	 * <p>
	 * The recursion index equals the maximum number of occurrences of the structure's name that can be found in 
	 * a single <i> argument </i> path of its syntax tree, minus one. <br>
	 * An argument path is one that does not end with a "function" leaf (see {@link ISyntaxLeaf}). <br>
	 * </p>
	 * 
	 * <p>
	 * How it works (<i> X </i> and <i> Y </i> are any substring) : <br>
	 * <i> a -> X -> a -> Y -> a </i> : first <i> A </i>'s recursion index is 2 <br>
	 * </p>.
	 * 
	 * <p>
	 * This method must be called first on every <i> argument </i> component of the branch. The returned maps are merged 
	 * in such a way that, if a symbol is mapped to different values, only the biggest value is kept. <br>
	 * If this branch's name is already mapped to a value, this value is incremented by one in the map and retained as 
	 * this branch's index value. If not, the map is updated with this branch's name mapped to its current recursion index 
	 * (which has to be 0). Finally, the map is returned. <br> 
	 * </p>
	 * 
	 * @return a mapping of every non functional
	 * @throws GrammarModelException 
	 */
	@Override
	Map<String, Integer> setRecursionIndex() throws GrammarModelException;

}
