package grammarModel.structure;

import java.util.List;
import java.util.Map;

import grammarModel.exceptions.GrammarModelException;
import grammarModel.utils.ITreePaths;
import representation.dataFormats.IBinaryRelation;
import representation.dataFormats.IDescription;
import representation.dataFormats.IFunctionalExpression;

/**
 * <p>
 * Any <i> class </i> implementing the syntactic structure interface defines an element (derivation rule or 
 * terminal symbol) of a context-free grammar. <br> 
 * The composition relationship that defines a type in object-oriented programming ("any instance of class <i> A </i>
 * has an instance of class <i> B </i> and an instance of class <i> C </i> for components") is used here as an equivalent 
 * to the derivation rule of a context-free grammar ("the symbol <i> A </i> can be substituted by the string of symbols 
 * <i> BC </i> ").
 * </p>
 * 
 * <p>
 * Thus, any <i> instance </i> of a class implementing the syntactic structure interface represents a 
 * derivation of a given symbol in the form of a syntax tree, which has this symbol as a root (and as its unique 
 * element if the symbol is a terminal). This symbol gives the structure its name. As a result of this derivation, 
 * any syntactic structure instance yields a string of terminals that forms a <i> functional expression </i>, which 
 * is a descriptive statement about the object to which this structure is associated. This description can also be 
 * provided as a <i> binary relation </i>. 
 * (see {@link IDescription}) <br>
 * </p> 
 * 
 * <p> 
 * Accordingly, the syntactic structure interface can be extended in order to describe : <br> 
 * 1/ a <i> syntax leaf </i>, which is a syntax tree terminal node : {@link ISyntaxLeaf}. A leaf can either be a 
 * function, or a variable given as an argument to a function. <br> 
 * 2/ a <i> syntax branch </i>, which is a derivation from a non-terminal node : {@link ISyntaxBranch}. A syntax branch 
 * has two components or more. The first component is a 'function' leaf ; its arguments are the strings of 
 * terminals resulting from the derivation of every other components.  <br>
 * 3/ a <i> syntax tree </i>, which is a syntax branch whose name is the start element of the context-free 
 * grammar at use <br>
 * 4/ a <i> syntax grove </i>, which is a list of syntax trees : {@link ISyntaxGrove}. <br>
 * </p>
 * 
 * @see representation.dataFormats.IDescription
 * @see representation.dataFormats.IBinaryRelation
 * @see representation.dataFormats.IFunctionalExpression
 * @see grammarModel.structure.ISyntaxLeaf
 * @see grammarModel.structure.ISyntaxBranch
 * @see grammarModel.structure.ISyntaxGrove
 * @author Gael Tregouet
 *
 */
public interface ISyntacticStructure extends Cloneable {

	//getters
	
	/**
	 * 
	 * @return a clone object
	 * @throws CloneNotSupportedException
	 */
	ISyntacticStructure clone();
	
	/**
	 * Returns the functional expression generated by the syntactic structure, encoded as a binary relation.
	 * 
	 * @return a description, in the form of a binary relation, of the object associated with the syntactic structure 
	 */
	IBinaryRelation getBinaryRelation();
	
	/**
	 * Returns the functional expression generated by the syntactic structure.
	 * 
	 * @return a description, in the form of a functional relation, of the object associated with the syntactic structure 
	 */
	IFunctionalExpression getFunctionalExpression();
	
	/**
	 * Returns the list of the structure's components. Each component name is one of the right-terms of the grammatical 
	 * rule to which this structure is associated. <br>
	 * 
	 * @return the list of this structure's components.
	 */
	List<ISyntacticStructure> getListOfComponents();
	
	/**
	 * Returns the list of IDs associated with any terminal ({@link ISyntaxLeaf}) derived from a structure's root.
	 * 
	 * @see grammarModel.structure.ISyntaxLeaf
	 * @return the list of IDs associated with any terminal ({@link ISyntaxLeaf}) derived from this structure's root. 
	 */
	List<Long> getListOfLeafIDs();	
	
	/**
	 * <p>
	 * Returns the name of the syntactic structure, which is the left-term of the grammatical rule to which it is 
	 * associated. <br>
	 * </p> 
	 * 
	 * <p>
	 * A syntactic structure instance can be regarded as a syntax tree ; in this case, the structure's name is the 
	 * tree's root. <br>
	 * </p>
	 * 
	 * @return the name of the syntactic structure
	 */
	String getName();
	
	/**
	 * Returns the list of paths (as a list of lists of strings) in the structure's tree, from the symbol that gives 
	 * the syntactic structure its name to any reachable terminal. <br>
	 * 
	 * @return the list of paths from the symbol that gives the syntactic structure its name to any reachable terminal.
	 */
	List<List<String>> getPathsAsListsOfStrings();	
	
	/**
	 * <p>
	 * The recursion index equals the maximum number of occurrences of the structure's name that can be found in 
	 * a single <i> argument </i> path of its syntax tree, minus one. <br>
	 * 
	 * An argument path is a path that does not lead to the structure's <i> function </i> (see {@link ISyntaxBranch}). <br>
	 * 
	 * The recursion index is used to make sure that two different structures can never yield the same 
	 * binary relation. It allows the addition a distinctive mark to the function leaves derived from recursive symbols
	 * (see {@link #markRecursion()}). <br>
	 * </p>
	 * 
	 * <p>
	 * How it works (<i> X </i> and <i> Y </i> being any substring of the path) : <br>
	 * <i> aXaYa </i> : first <i> a </i>'s recursion index is 2
	 * </p>
	 * 
	 * @see grammarModel.structure.ISyntaxBranch
	 * @see representation.dataFormats.IBinaryRelation
	 * @see #markRecursion()
	 * @return the recursion index of this structure
	 */
	int getRecursionIndex();	
	
	/**
	 * Returns the list of paths (with navigating functionalities) in this structure's tree, from the symbol that gives 
	 * the syntactic structure its name to any reachable terminal. <br>
	 * 
	 * @return the list of paths from the symbol that gives the syntactic structure its name to any reachable terminal.
	 * @throws GrammarModelException if tree path instantiation has failed
	 */
	ITreePaths getTreePaths() throws GrammarModelException;	
	
	//setters
	
	/**
	 * Adds a distinctive mark to the function leaves derived from recursive symbols. <br> 
	 * 
	 * If 'a' is a branch of type {A} that leads to a sub-branch of the same type : a(A#, (...(a(A,(...)))...)
	 * @param recursionIndex
	 * @throws GrammarModelException if the recursion index hasn't be set beforehand
	 */
	void markRecursion() throws GrammarModelException;	
	
	/**
	 * <p>
	 * Replaces a terminal ({@link ISyntaxLeaf}) argument by a new argument, provided that the terminal is 
	 * declared as implementing an interface whose the new argument is also an implementation of. <br>
	 * </p>
	 * 
	 * <p>
	 * Syntax tree 'growth' involves the replacement of leaves by new branches ({@link ISyntaxBranch}) ; 
	 * or, rarely, by new leaves. <br> 
	 * These new argument are injected in the structure with the IDs of the leaf they are meant to replace. If one 
	 * of the structure argument is a target leaf, then it is replaced ; otherwise, the same method is recursively 
	 * called on every argument, with the same parameters. <br>
	 * </p>
	 * 
	 * @see grammarModel.structure.ISyntaxLeaf
	 * @param newArg new argument
	 * @param leafIDs IDs of the leaves to be replaced
	 * @throws GrammarModelException if a replacement is attempted although the recursion index has already been set.
	 * (See {@link ISyntaxBranch#setRecursionIndex()})
	 * @return true if a replacement has occurred. 
	 */
	boolean replaceArguments(ISyntacticStructure newArg, List<Long> leafIDs) throws GrammarModelException;
	
	/**
	 * <p>
	 * The recursion index equals the maximum number of occurrences of the structure's name that can be found in 
	 * a single <i> argument </i> path of its syntax tree, minus one. <br>
	 * An argument path is one that does not end with a "function" leaf (see {@link ISyntaxLeaf}). <br>
	 * </p>
	 * 
	 * <p>
	 * How it works (<i> X </i> and <i> Y </i> are any substring) : <br>
	 * <i> A -> X -> A -> Y -> A -> Z </i> : first <i> A </i>'s recursion index is 2 <br>
	 * </p>
	 * 
	 * <p>
	 * No structure replacement ( {@link ISyntaxBranch#replaceArguments(ISyntacticStructure, List)}) is allowed 
	 * after the recursion index has been set. 
	 * </p>
	 * 
	 * @see grammarModel.structure.ISyntaxLeaf
	 * @return a mapping of every non functional structure's name in the branch to its recursion index 
	 */
	Map<String, Integer> setRecursionIndex();
		
}
