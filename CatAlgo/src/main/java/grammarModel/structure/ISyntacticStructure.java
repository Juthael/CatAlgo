package grammarModel.structure;

import java.util.List;
import java.util.Map;
import java.util.Set;

import grammarModel.exceptions.GrammarModelException;
import grammarModel.genericTools.IPosetMaxChains;
import grammarModel.genericTools.ISyntacticChains;
import propertyPoset.IImplication;

/**
 * ISyntacticStructure is an abstract class that is used to represent the nodes of a syntactic tree. 
 * The composition relationship between ISyntacticStructure objects is an equivalent to the derivation relationship 
 * between nodes of a syntactic tree. Therefore, ISyntacticStructure can be extended in order to represent : 
 * 1/ a syntactic tree terminal node (or 'syntactic leaf') 2/ the derivation from a non-terminal node ('syntactic branch') 
 * 3/ a whole syntactic tree (also a 'syntactic branch', but whose name is the start element of the context-free 
 * grammar at use) 
 * 4/ a list of syntactic trees (called a 'syntactic glove').
 *  
 * @author Gael Tregouet
 *
 */
public interface ISyntacticStructure extends Cloneable {

	/**
	 * @return the name (or type) of this structure, which is also the name of the generating node in the syntactic tree 
	 * from which its components are derived : it therefore refers to a grammatical element of the context-free grammar 
	 * at use. 
	 * Two different syntactic structures can have the same name if this name is a non-terminal element (or 'variable') 
	 * of the context-free grammar that can lead to different derivations.
	 */
	String getName();
	
	/**
	 * @return a list of chains that contains all the spanning paths of the syntactic structure (from its 
	 * generating node to one of its terminals).   
	 * @throws GrammarModelException
	 */
	ISyntacticChains getSyntacticChains() throws GrammarModelException;
	
	/**
	 * @return the set of spanning paths associated with this structure, plus all the sets associated with any of 
	 * its components, sub-components. etc. 
	 * @throws GrammarModelException
	 */
	Set<ISyntacticChains> getSetOfSyntacticChains() throws GrammarModelException;
	
	/**
	 * @return the set of spanning chains of the poset (lower semilattice) that can be derived from this 
	 * syntactic structure.
	 * @see IOriginalPropertyPoset
	 * @throws GrammarModelException
	 */
	IPosetMaxChains getPosetMaxChains() throws GrammarModelException;
	
	/**
	 * 
	 * @return the set of implications associated with the poset (lower semilattice) that can be derived from this
	 * syntactic structure.
	 * @see IPosetMaxChains
	 * @throws GrammarModelException
	 */
	Set<IImplication> getImplications() throws GrammarModelException;
	
	/**
	 * A syntactic structure R is redundant if it is a component of a structure A, and if another component of A 
	 * contains a similar structure R'. 
	 * Put another way : a syntactic structure R is redundant if it is a component of a structure A, and if the string
	 * of terminals generated by R is included in the string of terminal generated by another component of A.  
	 * @return true if this structure is redundant. 
	 */
	boolean isRedundant();
	
	/**
	 * Looks for redundancies in this structure components, sub-components, etc. 
	 * A syntactic structure R is redundant if it is a component of a structure A, and if another component of A 
	 * contains a similar structure R'. 
	 * Put another way : a syntactic structure R is redundant if it is a component of a structure A, and if the string
	 * of terminals generated by R is included in the string of terminal generated by another component of A.  
	 */
	void markRedundancies();
	
	/**
	 * Marks this structure and all its potential components, sub-components, etc., as redundant. 
	 * A syntactic structure R is redundant if it is a component of a structure A, and if another component of A 
	 * contains a similar structure R'. 
	 * Put another way : a syntactic structure R is redundant if it is a component of a structure A, and if the string
	 * of terminals generated by R is included in the string of terminal generated by another component of A.  
	 */
	void setAsRedundant();		
	
	ISyntacticStructure clone();
	
	/**
	 * A 'poset element name' is used to generate the property poset spanning chains from the syntactic structure, 
	 * and ultimately the property poset itself.
	 * It is a concatenation of the syntactic element 'name' with an index generated to assure that that structures 
	 * belonging to the same 'syntactic glove' can't return the same 'poset element name' if they don't have the same 
	 * components. 
	 * Put another way : two nodes from syntactic trees belonging to the same glove (and possibly having the same name) 
	 * can't generate the same 'poset element name' if they don't also generate the same derivation.
	 * 
	 * @see IPosetMaxChains, IOriginalPropertyPoset
	 * 
	 * @return a 'poset element name'.   
	 * @throws GrammarModelException
	 */
	String getPosetElementName() throws GrammarModelException;
	
	/**
	 * @return the list of component structures. The composition relationship between ISyntacticStructure objects 
	 * being an equivalent to the derivation relationship between nodes of a syntactic tree, component structures 
	 * represent the nodes of a syntactic tree that are directly derived from the generating node of this structure
	 * (the one that gives this structure its name). 
	 */
	List<ISyntacticStructure> getListOfComponents();
	
	/**
	 * @return  a list of lists of strings, representing all the spanning paths of the syntactic structure 
	 * (leading from its generating node to one of its terminals).
	 */
	List<List<String>> getListOfSyntacticStringChains();
	
	/**
	 * @return  a list of lists of strings, representing the set of spanning chains of the poset (lower semilattice) 
	 * that can be derived from this syntactic structure.
	 */
	List<List<String>> getListOfPosetMaxStringChains() throws GrammarModelException;
	
	/**
	 * @return the list of IDs associated with every syntactic leaf that can be derived from this structure's generating 
	 * node. 
	 * (All syntactic leaves have a leafID). 
	 */
	List<Long> getListOfLeafIDs();
	
	/**
	 * @return a concatenation (with a separator) of the chain of syntactic leaves (or terminals) that can be derived from 
	 * this structure's generating node. If the node is itself a terminal (because the structure is a syntactic leaf),  
	 * its name is returned.  
	 */
	String getStringOfTerminals();
	
	/**
	 * @return true if this structure has been provided with an ID, and can subsequently generate a 'poset element name'.
	 */
	boolean getIDHasBeenSet();
	
	/**
	 * @param prop property name, referring to an element of the context-free grammar at use. 
	 * @return true if the parameter is the name of this structure generating node, or the name of any derived
	 * node in the syntactic tree.  
	 */
	boolean hasThisProperty(String prop);
		
	/**
	 * Provides this structure (and its components, sub-components, etc.) with a 'poset element ID', mapped with 
	 * its generated list of chains.
	 * @see ISyntacticGrove
	 * @param chainsToIndex a map that associates syntactic chains with a unique ID. 
	 * @throws GrammarModelException
	 */
	void setPosetElementID(Map<ISyntacticChains, String> chainsToIndex) throws GrammarModelException;
	
	/**
	 * Replaces a target leaf component by a new component. 
	 * Syntactic tree growth involves the replacement of leaves by new branches (or, rarely, by new leaves). 
	 * These new components are injected in the structure whith the IDs of the leaf they are meant to replace. If one 
	 * of the structure component is a target leaf, then it is replaced ; otherwise, the same method is recursively 
	 * called on every non-terminal component, with the same parameters.  
	 * @param newComp new syntactic component
	 * @param compIDs IDs of the leaves to be replaced
	 * @return true if a replacement has occurred. 
	 */
	boolean replaceComponents(ISyntacticStructure newComp, List<Long> compIDs);
		
}
